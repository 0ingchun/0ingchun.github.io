{"version":3,"file":"Kotlin-DateTime-library-kotlinx-datetime-jsLegacy.js","sources":["../../../../../core/commonMain/src/DateTimePeriod.kt","text/StringBuilder.kt","time/Duration.kt","../../../../../core/commonMain/src/DateTimeUnit.kt","util/Preconditions.kt","../../../../../core/commonMain/src/Instant.kt","../../../../../core/commonMain/src/math.kt","../../../../../core/jsMain/src/Instant.kt","kotlin/math.kt","../../../../../core/commonMain/src/Clock.kt","util/Standard.kt","../../../../../core/commonMain/src/DayOfWeek.kt","../../../../../core/commonMain/src/Exceptions.kt","../../../../../core/commonMain/src/LocalDate.kt","../../../../../core/commonMain/src/LocalDateTime.kt","../../../../../core/commonMain/src/Month.kt","../../../../../core/commonMain/src/TimeZone.kt","../../../../../core/jsMain/src/DayOfWeek.kt","../../../../../core/jsMain/src/JSJodaExceptions.kt","../../../../../core/jsMain/src/LocalDate.kt","../../../../../core/jsMain/src/LocalDateTime.kt","../../../../../core/jsMain/src/Month.kt","../../../../../core/jsMain/src/TimeZone.kt","../../../../../core/jsMain/src/mathJs.kt"],"sourcesContent":[null,"/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.*\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\nexpect class StringBuilder : Appendable, CharSequence {\n    /** Constructs an empty string builder. */\n    constructor()\n\n    /** Constructs an empty string builder with the specified initial [capacity]. */\n    constructor(capacity: Int)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    constructor(content: CharSequence)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] string. */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    constructor(content: String)\n\n    override val length: Int\n\n    override operator fun get(index: Int): Char\n\n    override fun subSequence(startIndex: Int, endIndex: Int): CharSequence\n\n    override fun append(value: Char): StringBuilder\n    override fun append(value: CharSequence?): StringBuilder\n    override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    fun reverse(): StringBuilder\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    fun append(value: Any?): StringBuilder\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: Boolean): StringBuilder\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun append(value: CharArray): StringBuilder\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: String?): StringBuilder\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    fun capacity(): Int\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun ensureCapacity(minimumCapacity: Int)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Boolean): StringBuilder\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Char): StringBuilder\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharArray): StringBuilder\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharSequence?): StringBuilder\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Any?): StringBuilder\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: String?): StringBuilder\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun setLength(newLength: Int)\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int): String\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int, endIndex: Int): String\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun trimToSize()\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\npublic expect fun StringBuilder.clear(): StringBuilder\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect operator fun StringBuilder.set(index: Int, value: Char)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteAt(index: Int): StringBuilder\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n@Deprecated(\"Use append(value: Any?) instead\", ReplaceWith(\"append(value = obj)\"), DeprecationLevel.WARNING)\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.append(obj: Any?): StringBuilder = this.append(obj)\n\n/**\n * Builds new string by populating newly created [StringBuilder] using provided [builderAction]\n * and then converting it to [String].\n */\n@kotlin.internal.InlineOnly\npublic inline fun buildString(builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder().apply(builderAction).toString()\n}\n\n/**\n * Builds new string by populating newly created [StringBuilder] initialized with the given [capacity]\n * using provided [builderAction] and then converting it to [String].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun buildString(capacity: Int, builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder(capacity).apply(builderAction).toString()\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: String?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: Any?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this StringBuilder. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(): StringBuilder = append('\\n')\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharSequence?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: String?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Any?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharArray): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Char): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Boolean): StringBuilder = append(value).appendLine()\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.contracts.*\nimport kotlin.math.abs\n\n@OptIn(ExperimentalTime::class)\nprivate inline val storageUnit get() = DurationUnit.NANOSECONDS\n\n/**\n * Represents the amount of time one instant of time is away from another instant.\n *\n * A negative duration is possible in a situation when the second instant is earlier than the first one.\n * An infinite duration value [Duration.INFINITE] can be used to represent infinite timeouts.\n *\n * To construct a duration use either the extension function [toDuration],\n * or the extension properties [hours], [minutes], [seconds], and so on,\n * available on [Int], [Long], and [Double] numeric types.\n *\n * To get the value of this duration expressed in a particular [duration units][DurationUnit]\n * use the functions [toInt], [toLong], and [toDouble]\n * or the properties [inHours], [inMinutes], [inSeconds], [inNanoseconds], and so on.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\npublic inline class Duration internal constructor(internal val value: Double) : Comparable<Duration> {\n// TODO: backend fails on init block, wait for KT-28055\n\n//    init {\n//        require(_value.isNaN().not())\n//    }\n\n    companion object {\n        /** The duration equal to exactly 0 seconds. */\n        public val ZERO: Duration = Duration(0.0)\n\n        /** The duration whose value is positive infinity. It is useful for representing timeouts that should never expire. */\n        public val INFINITE: Duration = Duration(Double.POSITIVE_INFINITY)\n\n        /** Converts the given time duration [value] expressed in the specified [sourceUnit] into the specified [targetUnit]. */\n        public fun convert(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double =\n            convertDurationUnit(value, sourceUnit, targetUnit)\n    }\n\n    // arithmetic operators\n\n    /** Returns the negative of this value. */\n    public operator fun unaryMinus(): Duration = Duration(-value)\n\n    /** Returns a duration whose value is the sum of this and [other] duration values. */\n    public operator fun plus(other: Duration): Duration = Duration(value + other.value)\n\n    /** Returns a duration whose value is the difference between this and [other] duration values. */\n    public operator fun minus(other: Duration): Duration = Duration(value - other.value)\n\n    /** Returns a duration whose value is this duration value multiplied by the given [scale] number. */\n    public operator fun times(scale: Int): Duration = Duration(value * scale)\n\n    /** Returns a duration whose value is this duration value multiplied by the given [scale] number. */\n    public operator fun times(scale: Double): Duration = Duration(value * scale)\n\n    /** Returns a duration whose value is this duration value divided by the given [scale] number. */\n    public operator fun div(scale: Int): Duration = Duration(value / scale)\n\n    /** Returns a duration whose value is this duration value divided by the given [scale] number. */\n    public operator fun div(scale: Double): Duration = Duration(value / scale)\n\n    /** Returns a number that is the ratio of this and [other] duration values. */\n    public operator fun div(other: Duration): Double = this.value / other.value\n\n    /** Returns true, if the duration value is less than zero. */\n    public fun isNegative(): Boolean = value < 0\n\n    /** Returns true, if the duration value is greater than zero. */\n    public fun isPositive(): Boolean = value > 0\n\n    /** Returns true, if the duration value is infinite. */\n    public fun isInfinite(): Boolean = value.isInfinite()\n\n    /** Returns true, if the duration value is finite. */\n    public fun isFinite(): Boolean = value.isFinite()\n\n    /** Returns the absolute value of this value. The returned value is always non-negative. */\n    public val absoluteValue: Duration get() = if (isNegative()) -this else this\n\n    override fun compareTo(other: Duration): Int = this.value.compareTo(other.value)\n\n\n    // splitting to components\n\n    /**\n     * Splits this duration into days, hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration, and its absolute value is less than 24;\n     * - `days` represents the whole number of days in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (days: Int, hours: Int, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inDays.toInt(), hoursComponent, minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (hours: Int, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inHours.toInt(), minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inMinutes.toInt(), secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration.\n     *   If the value doesn't fit in [Long] range, i.e. it's greater than [Long.MAX_VALUE] or less than [Long.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (seconds: Long, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inSeconds.toLong(), nanosecondsComponent)\n    }\n\n    @PublishedApi\n    internal val hoursComponent: Int get() = (inHours % 24).toInt()\n    @PublishedApi\n    internal val minutesComponent: Int get() = (inMinutes % 60).toInt()\n    @PublishedApi\n    internal val secondsComponent: Int get() = (inSeconds % 60).toInt()\n    @PublishedApi\n    internal val nanosecondsComponent: Int get() = (inNanoseconds % 1e9).toInt()\n\n\n    // conversion to units\n\n    /** Returns the value of this duration expressed as a [Double] number of the specified [unit]. */\n    public fun toDouble(unit: DurationUnit): Double = convertDurationUnit(value, storageUnit, unit)\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of the specified [unit].\n     *\n     * If the value doesn't fit in the range of [Long] type, it is coerced into that range, see the conversion [Double.toLong] for details.\n     */\n    public fun toLong(unit: DurationUnit): Long = toDouble(unit).toLong()\n\n    /**\n     * Returns the value of this duration expressed as an [Int] number of the specified [unit].\n     *\n     * If the value doesn't fit in the range of [Int] type, it is coerced into that range, see the conversion [Double.toInt] for details.\n     */\n    public fun toInt(unit: DurationUnit): Int = toDouble(unit).toInt()\n\n    /** The value of this duration expressed as a [Double] number of days. */\n    public val inDays: Double get() = toDouble(DurationUnit.DAYS)\n\n    /** The value of this duration expressed as a [Double] number of hours. */\n    public val inHours: Double get() = toDouble(DurationUnit.HOURS)\n\n    /** The value of this duration expressed as a [Double] number of minutes. */\n    public val inMinutes: Double get() = toDouble(DurationUnit.MINUTES)\n\n    /** The value of this duration expressed as a [Double] number of seconds. */\n    public val inSeconds: Double get() = toDouble(DurationUnit.SECONDS)\n\n    /** The value of this duration expressed as a [Double] number of milliseconds. */\n    public val inMilliseconds: Double get() = toDouble(DurationUnit.MILLISECONDS)\n\n    /** The value of this duration expressed as a [Double] number of microseconds. */\n    public val inMicroseconds: Double get() = toDouble(DurationUnit.MICROSECONDS)\n\n    /** The value of this duration expressed as a [Double] number of nanoseconds. */\n    public val inNanoseconds: Double get() = toDouble(DurationUnit.NANOSECONDS)\n\n    // shortcuts\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the value doesn't fit in the range of [Long] type, it is coerced into that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of nanoseconds is approximately \u00b1292 years.\n     */\n    public fun toLongNanoseconds(): Long = toLong(DurationUnit.NANOSECONDS)\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * The value is coerced to the range of [Long] type, if it doesn't fit in that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of milliseconds is approximately \u00b1292 million years.\n     */\n    public fun toLongMilliseconds(): Long = toLong(DurationUnit.MILLISECONDS)\n\n    /**\n     * Returns a string representation of this duration value expressed in the unit which yields the most compact and readable number value.\n     *\n     * Special cases:\n     *  - zero duration is formatted as `\"0s\"`\n     *  - the infinite duration is formatted as `\"Infinity\"` without unit\n     *  - very small durations (less than 1e-15 s) are expressed in seconds and formatted in scientific notation\n     *  - very big durations (more than 1e+7 days) are expressed in days and formatted in scientific notation\n     *\n     * @return the value of duration in the automatically determined unit followed by that unit abbreviated name: `d`, `h`, `m`, `s`, `ms`, `us`, or `ns`.\n     *\n     * @sample samples.time.Durations.toStringDefault\n     */\n    override fun toString(): String = when {\n        isInfinite() -> value.toString()\n        value == 0.0 -> \"0s\"\n        else -> {\n            val absNs = absoluteValue.inNanoseconds\n            var scientific = false\n            var maxDecimals = 0\n            val unit = when {\n                absNs < 1e-6 -> DurationUnit.SECONDS.also { scientific = true }\n                absNs < 1 -> DurationUnit.NANOSECONDS.also { maxDecimals = 7 }\n                absNs < 1e3 -> DurationUnit.NANOSECONDS\n                absNs < 1e6 -> DurationUnit.MICROSECONDS\n                absNs < 1e9 -> DurationUnit.MILLISECONDS\n                absNs < 1000e9 -> DurationUnit.SECONDS\n                absNs < 60_000e9 -> DurationUnit.MINUTES\n                absNs < 3600_000e9 -> DurationUnit.HOURS\n                absNs < 86400e9 * 1e7 -> DurationUnit.DAYS\n                else -> DurationUnit.DAYS.also { scientific = true }\n            }\n            val value = toDouble(unit)\n            when {\n                scientific -> formatScientific(value)\n                maxDecimals > 0 -> formatUpToDecimals(value, maxDecimals)\n                else -> formatToExactDecimals(value, precision(abs(value)))\n            } + unit.shortName()\n        }\n    }\n\n    private fun precision(value: Double): Int = when {\n        value < 1 -> 3\n        value < 10 -> 2\n        value < 100 -> 1\n        else -> 0\n    }\n\n    /**\n     * Returns a string representation of this duration value expressed in the given [unit]\n     * and formatted with the specified [decimals] number of digits after decimal point.\n     *\n     * Special cases:\n     *  - the infinite duration is formatted as `\"Infinity\"` without unit\n     *\n     * @return the value of duration in the specified [unit] followed by that unit abbreviated name: `d`, `h`, `m`, `s`, `ms`, `us`, or `ns`.\n     *\n     * @throws IllegalArgumentException if [decimals] is less than zero.\n     *\n     * @sample samples.time.Durations.toStringDecimals\n     */\n    public fun toString(unit: DurationUnit, decimals: Int = 0): String {\n        require(decimals >= 0) { \"decimals must be not negative, but was $decimals\" }\n        if (isInfinite()) return value.toString()\n        val number = toDouble(unit)\n        return when {\n            abs(number) < 1e14 -> formatToExactDecimals(number, decimals.coerceAtMost(12))\n            else -> formatScientific(number)\n        } + unit.shortName()\n    }\n\n\n    /**\n     * Returns an ISO-8601 based string representation of this duration.\n     *\n     * The returned value is presented in the format `PThHmMs.fS`, where `h`, `m`, `s` are the integer components of this duration (see [toComponents])\n     * and `f` is a fractional part of second. Depending on the roundness of the value the fractional part can be formatted with either\n     * 0, 3, 6, or 9 decimal digits.\n     *\n     * If the hours component absolute value of this duration is greater than [Int.MAX_VALUE], it is replaced with [Int.MAX_VALUE],\n     * so the infinite duration is formatted as `\"PT2147483647H\".\n     *\n     * Negative durations are indicated with the sign `-` in the beginning of the returned string, for example, `\"-PT5M30S\"`.\n     *\n     * @sample samples.time.Durations.toIsoString\n     */\n    @OptIn(ExperimentalStdlibApi::class)\n    public fun toIsoString(): String = buildString {\n        if (isNegative()) append('-')\n        append(\"PT\")\n        absoluteValue.toComponents { hours, minutes, seconds, nanoseconds ->\n            val hasHours = hours != 0\n            val hasSeconds = seconds != 0 || nanoseconds != 0\n            val hasMinutes = minutes != 0 || (hasSeconds && hasHours)\n            if (hasHours) {\n                append(hours).append('H')\n            }\n            if (hasMinutes) {\n                append(minutes).append('M')\n            }\n            if (hasSeconds || (!hasHours && !hasMinutes)) {\n                append(seconds)\n                if (nanoseconds != 0) {\n                    append('.')\n                    val nss = nanoseconds.toString().padStart(9, '0')\n                    when {\n                        nanoseconds % 1_000_000 == 0 -> appendRange(nss, 0, 3)\n                        nanoseconds % 1_000 == 0 -> appendRange(nss, 0, 6)\n                        else -> append(nss)\n                    }\n                }\n                append('S')\n            }\n        }\n    }\n\n}\n\n// constructing from number of units\n// extension functions\n\n/** Returns a [Duration] equal to this [Int] number of the specified [unit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Int.toDuration(unit: DurationUnit): Duration = toDouble().toDuration(unit)\n\n/** Returns a [Duration] equal to this [Long] number of the specified [unit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Long.toDuration(unit: DurationUnit): Duration = toDouble().toDuration(unit)\n\n/** Returns a [Duration] equal to this [Double] number of the specified [unit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Double.toDuration(unit: DurationUnit): Duration = Duration(convertDurationUnit(this, unit, storageUnit))\n\n// constructing from number of units\n// extension properties\n\n/** Returns a [Duration] equal to this [Int] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Double] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Double] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Double] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Double] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Long] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Double] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Int] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Long] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Double] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Int] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Int.days get() = toDuration(DurationUnit.DAYS)\n\n/** Returns a [Duration] equal to this [Long] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Long.days get() = toDuration(DurationUnit.DAYS)\n\n/** Returns a [Duration] equal to this [Double] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic val Double.days get() = toDuration(DurationUnit.DAYS)\n\n\n/** Returns a duration whose value is the specified [duration] value multiplied by this number. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.times(duration: Duration): Duration = duration * this\n\n/** Returns a duration whose value is the specified [duration] value multiplied by this number. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@kotlin.internal.InlineOnly\npublic inline operator fun Double.times(duration: Duration): Duration = duration * this\n\n\ninternal expect fun formatToExactDecimals(value: Double, decimals: Int): String\ninternal expect fun formatUpToDecimals(value: Double, decimals: Int): String\ninternal expect fun formatScientific(value: Double): String",null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n",null,null,null,"/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n",null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n",null,null,null,null,null,null,null,null,null,null,null,null,null],"names":[],"mappings":"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"}